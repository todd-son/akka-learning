# 용어정리

### Concurrency vs Parallelism

동시성이라는 비록 동시에 수행되지 않더라도 둘 혹은 그 이상의 Task가 하나의 프로세스를 구성할 때를 의미한다.
병렬성은 동시에 실행이 일어나는 것을 의미한다.

### Asynchronous vs Synchronous

동기란 콜러가 메소드를 호출하고 응답이나 오류를 기다리는 동안 다른 프로세스를 진행하지 않는다는 것을 의미한다.
반대로 비동기란 콜러가 호출하고 다른 프로세스를 진행하는 것이며 응답에 대한 결과를 수행하기 위해서는 추가적인 메커니즘이 필요하다.(Callback, Future, Message)

### Non-blocking vs Blocking

일반적으로 다른 스레드의 실행을 무한정으로 기다리는 것을 블락킹 상태라고 한다.   
반대로 기다리는 스레드가 없다면 논블락킹이라고 한다.

### Deadlock vs Starvation vs LiveLock

데드락이란 여러 참여자가 서로 다른 참여자의 특정한 상태가 도달되기를 기다리면서 서로 블락킹되는 상태를 의미한다.
반대로 기아란 다른 참여자들의 수행때문에 하나 혹은 그 이상의 프로세스가 진행하지 못하는 것을 의미한다. 예를 들자면 우선순위 작업들이 계속 들어와서 후순위의 작업들이 수행되지 못하는 상황이 있을 수 있다.
라이브락은 데드락과 유사하게 프로세스를 진행하는 참여자가 없다. 차이는 서로 대기에 의해 상태가 고정되어 버리는 것이 아니라. 상태가 계속 바뀐다는 것이다.

### Race Condition

경쟁상태라 이벤트의 순서에 따라 서로 다른 참여자의 결과에 영향을 주는 것을 의미한다. 예를 들어 내가 상태를 변경하고 리턴받기던에 다른 참여자가 상태를 바꿔버리는 것을 의미한다.

### Non-blocking Guarantees

#### Wait-freedom

모든 호출이 한정된 스텝안에 종료된다면 wait-free이다.

#### Lock-freedom

Lock-free는 wait-free보다 약하다. 데드락이 발생하지 않는 정의를 의마한다. 다시 말하자면 대부분의 호출은 한정된 단계에서 끝나지만 모든 호출이 그렇다는 것은 아니다. 다시 말하자면 기아 상태를 보장하지는 못한다.

#### Obstruction-freedom

가장 약한 방식. 특정 시간이 흐르뒤에 실행을 분리시켜 버린다. Optimistic concurrency control이 이 방식인데 모든 참여자가 공유 객체에 접근할 수 있지만 충돌이 발생하면 롤백 시킨다.

# Actor Systems

액터는 상태와 동작을 캡슐화한 객체이다. 커뮤니케이션은 수취인의 메일박스와 메시지를 교환하는 것이다. OOP와 매우 다르다. 

## Hierarchical Structure

기본적으로 계층 구조를 가진다. 그리고 각 액터는 정확히 하나의 감독자만을 가지는데 자신을 생성한 액터이다
특정 액터가 장애가 나면 그 실패는 바로 감독자에게 통보된다. 이런 레이어 구조가 더 쉽게 실패에 방어적인 프로그램을 쉽게 작성할 수 있게 한다.

## Configuration Container

아카 자체의 공유되는 글로벌 설정이 없으므로, 같은 JVM 위에 여러개의 액터시스템이 존재할 수 있다. 메시지를 전송함으로써 여러개의 액터시스템을 쉽게 통합할 수 있다.

## Actor Best Practices

- 액터는 멋진 동료여야 한다. 작업을 효율적으로 하기 위해서 리소를 점유하지 말아야 한다. 액터는 외부 자원에 의해 블락되지 않아야 한다.
- 액터간에 Mutable 객체를 전달하지 말라.
- 메시지에 동작을 전달하지 말라. 예를 들자면 실수로 클로저의 변수를 같이 넘겨버릴 수 있다. 이것에 의해 액터간의 mutable 상태가 생기고 액터 모델의 장점을 없애 버릴 것이다.
- 탑레벨 액터는 최대한 적게 만들고 액터를 계층 구조로 구성해라. 이는 에러처리를 용이하게 할 것이다.

## What you should not concern yourself with

액터 시스템을 액터를 실행하기 위한 리소스를 관리한다. 어떤 시스템 내에는 수백만의 액터가 있을 수 있다. 그런 시스템에서로 러프하게 각 인스턴스당 300 바이트의 오버헤드가 발생한다.

# What is an actor?

액터는 State, Behavior, Mailbox, Child Actors, Supervisor Strategy 로 구성된다. 

## ActorReference

액터는 캡슐화되어 있기 때문에 외부에서 액터를 참조할려면 ActorRef를 사용해야 된다. 

## State 

액터는 일반적으로 상태를 표현할 수 있는 몇몇의 변수를 가질 수 있음. 락없이 데이터의 변경이 보호됨

## Behavior

모든 메시지는 처리되어야 한다. 메시지에 응답하여 동작하는 함수를 Behivor라고 한다. 

## Mailbox

메시지 전송으로 전송자가 수신자의 메일박스에 접속하는 것이다. 기본동작은 FIFO 이지만 Priority 큐로 구성할 수도 있다. 

## Child Actor

모든 액터는 잠재적으로 감독자. 누구든 자식 액터를 만들 수 있고 서브 타스크를 위임할 수 있다.

## Supervisor Strategy 

각 액터마다 다른 전략을 가질 수 있으며 자세한건 뒤에 설명 

# Supervision and Monitoring

## What Supervision Means

액터시스템에서 Supervison 이란 액터간의 디펜던시를 표현한다. 슈버파이저는 그들의 종속자들에게 타스크를 할당하고 실패에 대한 응답을 처리해야 한다.
종속자에서 에러가 발생하면 자신의 종료되고 모든 종속자와 슈퍼바이저에게 실패 메시지가 전송된다. 종속자의 실패시 슈퍼바이저가 할 수 있는 행동은 다음과 같다.

- 종속자를 계속 수행시키고 종속자의 집계된 내부 상태에 유지한다.
- 종속자를 재시작시키고 종속자의 내부 상태를 지운다.
- 종속자를 영원히 중지시킨다.
- 실패를 에스칼레이트 시킨다. 즉 슈퍼바이저도 실패가 된다.

## What Lifecycle Monitoring Means

부모 자식간의 모니터링 뿐만 아니라 각 Actor 끼리도 모니터링이 이루어진다. 

## One-For-One Strategy vs. All-For-One Strategy

슈퍼비전 전략에는 두가지 클래스가 있다. (OneForOneStrategy, AllForOneStrategy)

- OneForOneStrategy : 에러 발생시 해당 액터에만 해당 전략이 적용된다.
- AllForOneStrategy : 에러 발생시 해당 액터에만이 아니라 모든 동료 액터들에게도 해당 전략이 적용된다.
 
